#
# Copyright (C) 1998-2001, The University of Queensland
# Copyright (C) 2001, Sun Microsystems, Inc
#
# See the file "LICENSE.TERMS" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL
# WARRANTIES.
#

# File: pentium.ssl
# Desc: This file contains a semantic description of the 80386 and 387
#       processors. 
#

# $Revision: 1.34 $		// 1.28.2.1
# 16 Oct 98 - Mike: lower case register names to be consistent with sparc
# 20 Nov 02 - Mike: Fixed MOV.ED.IVOD and MOV.EW.IVOW
# 20 Jul 04 - Mike: Fixed FISUB, FISUBR
# 01 Jul 05 - Mike: FIMUL, FIADD.i64 -> .i16

# Constants defined in hexadecimal (modelling manual) 
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
MAX64BITS := 0xFFFFFFFFFFFFFFFF;
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;

INTEGER
[ %eax, %ecx, %edx, %ebx,
  %esp, %ebp, %esi, %edi ][32] -> 24..31,
%ax[16] -> 0 SHARES %eax@[0..15],
%cx[16] -> 1 SHARES %ecx@[0..15],
%dx[16] -> 2 SHARES %edx@[0..15],
%bx[16] -> 3 SHARES %ebx@[0..15],
%sp[16] -> 4 SHARES %esp@[0..15],
%bp[16] -> 5 SHARES %ebp@[0..15],
%si[16] -> 6 SHARES %esi@[0..15],
%di[16] -> 7 SHARES %edi@[0..15],
%al[8]  -> 8 SHARES %ax@[0..7],
%cl[8]  -> 9 SHARES %cx@[0..7],
%dl[8]  -> 10 SHARES %dx@[0..7],
%bl[8]  -> 11 SHARES %bx@[0..7],
%ah[8]  -> 12 SHARES %ax@[8..15],
%ch[8]  -> 13 SHARES %cx@[8..15],
%dh[8]  -> 14 SHARES %dx@[8..15],
%bh[8]  -> 15 SHARES %bx@[8..15],
%es[8]  -> 16,
%cs[8]  -> 17,
%ss[8]  -> 18,
%ds[8]  -> 19,
%pc[32] -> -1,
[ %NF, %ZF, %AF, %PF,
  %CF, %OF, %DF, %IF,
  %FP, %SKIP, %RPT, %FLF,
  %C1, %C2, %FZF ][1] -> -1;

FLOAT
[ %st, %st1,        # stack head, stack neck
  %st2, %st3, %st4, %st5, %st6, %st7 ][80] -> 32..39;

INTEGER
# Note: for boomerang, we use the abstract floating point flags %fflags now
%fsw[16] -> 40, #Float status word(16 Bit register Containing information about
                #The state of the FPU.  stores the top of stack pointer
                #information aswell as the exception flags and stack fault
                #information)

%fstp[8] -> 41, #Floating point stack pointer.  Holds the top of stack pointer.
                #NB is bits 11->13 inclusive of the fsw(defined above).

%fcw[16] -> 42; #Floating point Control Word (16 bit register holding
                #information such as the infinity control, rounding control,
                #precision control and exception masks.


ADDFLAGS8(op1, op2, result)  {
            *1* %CF := ((op1@[7:7]) & (op2@[7:7]))
                        | (~(result@[7:7]) & ((op1@[7:7]) | (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) & (op2@[7:7]) & ~(result@[7:7]))
                        | (~(op1@[7:7]) & ~(op2@[7:7]) & (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS16(op1, op2, result)  {
            *1* %CF := ((op1@[15:15]) & (op2@[15:15]))
                        | (~(result@[15:15]) & ((op1@[15:15]) | (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) & (op2@[15:15]) & ~(result@[15:15]))
                        | (~(op1@[15:15]) & ~(op2@[15:15]) & (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS32(op1, op2, result)  {
            *1* %CF := ((op1@[31:31]) & (op2@[31:31]))
                        | (~(result@[31:31]) & ((op1@[31:31]) | (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) & (op2@[31:31]) & ~(result@[31:31]))
                        | (~(op1@[31:31]) & ~(op2@[31:31]) & (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS8(op1, op2, result)  {
            *1* %CF := (~(op1@[7:7]) & (op2@[7:7]))
                        | ((result@[7:7]) & (~(op1@[7:7]) | (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) & ~(op2@[7:7]) & ~(result@[7:7]))
                        | (~(op1@[7:7]) & (op2@[7:7]) & (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS16(op1, op2, result)  {
            *1* %CF := (~(op1@[15:15]) & (op2@[15:15]))
                        | ((result@[15:15]) & (~(op1@[15:15]) | (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) & ~(op2@[15:15]) & ~(result@[15:15]))
                        | (~(op1@[15:15]) & (op2@[15:15]) & (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#       *1*  %PF := ??
#       *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS32(op1, op2, result)  {
            *1* %CF := (~(op1@[31:31]) & (op2@[31:31]))
                        | ((result@[31:31]) & (~(op1@[31:31]) | (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) & ~(op2@[31:31]) & ~(result@[31:31]))
                        | (~(op1@[31:31]) & (op2@[31:31]) & (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGSFL(op1, op2) {
			*1* %CF := op1 < op2
			*1* %ZF := op1 = op2
};

LOGICALFLAGS8(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[7:7]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS16(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[15:15]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS32(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[31:31]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

IMULTFLAGS8(result)  {
            *1* %CF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
            *1* %OF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
};

IMULTFLAGS16(result)  {
            *1* %CF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
            *1* %OF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
};

IMULTFLAGS32(result)  {
            *1* %CF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
            *1* %OF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
};

MULTFLAGS8(result)  {
            *1* %CF := [result@[8:15]?1:0]
            *1* %OF := [result@[8:15]?1:0]
};

MULTFLAGS16(result)  {
            *1* %CF := [result@[16:31]?1:0]
            *1* %OF := [result@[16:31]?1:0]
};

MULTFLAGS32(result)  {
            *1* %CF := [result@[32:63]?1:0]
            *1* %OF := [result@[32:63]?1:0]
};

ROLFLAGS8(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[7:7])! = %CF:-1]
            *1* %CF := result@[7:7]
};

ROLFLAGS16(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[15:15])! = %CF:-1]
            *1* %CF := result@[15:15]
};

ROLFLAGS32(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[31:31])! = %CF:-1]
            *1* %CF := result@[31:31]
};

RORFLAGS8(result, op1, count)  {
            *1* %CF := result@[7:7]
            *1* %OF := [count = 1?(op1@[7:7])! = (op1@[6:6]):-1]
};

RORFLAGS16(result, op1, count)  {
            *1* %CF := result@[15:15]
            *1* %OF := [count = 1?(op1@[15:15])! = (op1@[14:14]):-1]
};

RORFLAGS32(result, op1, count)  {
            *1* %CF := result@[31:31]
            *1* %OF := [count = 1?(op1@[31:31])! = (op1@[30:30]):-1]
};

SALFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(8 - count):(9 - count)]
            *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SALFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(16 - count):(17 - count)]
            *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SALFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(32 - count):(33 - count)]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SARFLAGS(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?0:-1]
};

SHRFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SHRFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SHRFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(32 - count):(33 - count)]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(64 - count):(65 - count)]
            *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SHRDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(count - 1):count]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHRDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(count - 1):count]
            *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SETFFLAGS(op1, op2)  {
            *1* %FZF := [(op1 = op2) ? 1 : 0]
            *1* %FLF := [(op1 < op2) ? 1 : 0]
            *1* %C2 := 0 # [ (op1 > op2) ? 1 : 0]
};


ADDB dst, src
            *8* tmp1 := dst
            *8* dst := dst - src
            ADDFLAGS8(tmp1, src, dst);

ADDW dst, src
            *16* tmp1 := dst
            *16* dst := dst - src
            ADDFLAGS16(tmp1, src, dst);

ADDL dst, src
            *32* tmp1 := dst
            *32* dst := dst - src
            ADDFLAGS32(tmp1, src, dst);

SUBB dst, src
            *8* tmp1 := dst
            *8* dst := dst - src
            SUBFLAGS8(tmp1, src, dst);

SUBW dst, src
            *16* tmp1 := dst
            *16* dst := dst - src
            SUBFLAGS16(tmp1, src, dst);

SUBL dst, src
            *32* tmp1 := dst
            *32* dst := dst - src
            SUBFLAGS32(tmp1, src, dst);

BSWAP       reg32
            *32* tmp1 := zfill(8, 32, reg32@[31:24])
            *32* tmp2 := zfill(8, 32, reg32@[23:16])
            *32* tmp3 := zfill(8, 32, reg32@[15: 8])
            *32* tmp4 := reg32 & 0xFF
            *32* reg32 := (tmp4 << 24) + (tmp3 << 16) + (tmp2 << 8) + tmp1;

CMPB   dst, src 
            *8* tmp1 := dst - src
            SUBFLAGS32(dst, src, tmp1);

CMPW   dst, src 
            *16* tmp1 := dst - src
            SUBFLAGS16(dst, src, tmp1);

CMPL   dst, src 
            *32* tmp1 := dst - src
            SUBFLAGS32(dst, src, tmp1);

OP1 := { "&", "|", "^" };
LOG := { "AND", "OR", "XOR" };

LOG[IDX]"B" dst, src 
            *8* dst := dst OP1[IDX] src
            LOGICALFLAGS8(dst);

LOG[IDX]"W" dst, src 
            *16* dst := dst OP1[IDX] src
            LOGICALFLAGS16(dst);

LOG[IDX]"L" dst, src 
            *32* dst := dst OP1[IDX] src
            LOGICALFLAGS32(dst);

OP2 := { "+", "-" };
ARITH_C := { "ADC", "SBB" };

ARITH_C[IDX]^"IAL" i8 
            *8* tmp1 := %al
            *8* %al := %al OP2[IDX] i8 OP2[IDX] %CF;
ADC.IAL   i8 ADDFLAGS8(tmp1, i8, %al);
SBB.IAL   i8 SUBFLAGS8(tmp1, i8, %al);
ARITH_C[IDX]^"IAL"   i8 _;

ARITH_C[IDX]^"IAX" i16 
            *16* tmp1 := %ax
            *16* %ax := %ax OP2[IDX] i16 OP2[IDX] %CF;
ADCIAX   i16 ADDFLAGS16(tmp1, i16, %ax);
SBBIAX   i16 SUBFLAGS16(tmp1, i16, %ax);

ARITH_C[IDX]^"IEAX" i32 
            *32* tmp1 := %eax
            *32* %eax := %eax OP2[IDX] i32 OP2[IDX] %CF;
ADC.IEAX   i32 ADDFLAGS32(tmp1, i32, %eax);
SBB.IEAX   i32 SUBFLAGS32(tmp1, i32, %eax);

ARITH_C[IDX]^"ID" reg32, i32 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] i32 OP2[IDX] %CF;
ADC.ID   reg32, i32 ADDFLAGS32(tmp1, i32, reg32);
SBB.ID   reg32, i32 SUBFLAGS32(tmp1, i32, reg32);

ARITH_C[IDX]^"IW" reg16, i16 
            *16* tmp1 := reg16
            *16* reg16 := reg16 OP2[IDX] i16 OP2[IDX] %CF;
ADC.IW   reg16, i16 ADDFLAGS16(tmp1, i16, reg16);
SBB.IW   reg16, i16 SUBFLAGS16(tmp1, i16, reg16);

ARITH_C[IDX]^"IB" reg8, i8 
            *8* tmp1 := reg8
            *8* reg8 := reg8 OP2[IDX] i8 OP2[IDX] %CF;
ADC.IB   reg8, i8 ADDFLAGS8(tmp1, i8, reg8);
SBB.IB   reg8, i8 SUBFLAGS8(tmp1, i8, reg8);

ARITH_C[IDX]^"IODB" reg32, i8 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] i8 OP2[IDX] %CF;
ADC.IODB   reg32, i8 ADDFLAGS32(tmp1, i8, reg32);
SBB.IODB   reg32, i8 SUBFLAGS32(tmp1, i8, reg32);

ARITH_C[IDX]^"MRB" modrm, reg8 
            *8* tmp1 := modrm
            *8* modrm := tmp1 OP2[IDX] reg8 OP2[IDX] %CF;
ADC.MRB   modrm, reg8 ADDFLAGS8(tmp1, reg8, modrm);
SBB.MRB   modrm, reg8 SUBFLAGS8(tmp1, reg8, modrm);

ARITH_C[IDX]^"MROW" modrm, reg16 
            *16* tmp1 := modrm{16}
            *16* modrm := tmp1 OP2[IDX] reg16 OP2[IDX] %CF;
ADC.MROW   modrm, reg16 ADDFLAGS16(tmp1, reg16, modrm{16});
SBB.MROW   modrm, reg16 SUBFLAGS16(tmp1, reg16, modrm{16});

ARITH_C[IDX]^"MROD" modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP2[IDX] reg32 OP2[IDX] %CF;
ADC.MROD   modrm, reg32 ADDFLAGS32(tmp1, reg32, modrm);
SBB.MROD   modrm, reg32 SUBFLAGS32(tmp1, reg32, modrm);

ARITH_C[IDX]^"RMB" reg8, modrm 
            *8* tmpb := reg8
            *8* reg8 := reg8 OP2[IDX] modrm{8} OP2[IDX] %CF;
ADC.RMB   reg8, modrm ADDFLAGS8(tmpb, modrm{8}, reg8);
SBB.RMB   reg8, modrm SUBFLAGS8(tmpb, modrm{8}, reg8);

ARITH_C[IDX]^"RMOW" reg16, modrm 
            *16* tmph := reg16
            *16* reg16 := reg16 OP2[IDX] modrm{16} OP2[IDX] %CF;
ADC.RMOW   reg16, modrm ADDFLAGS16(tmph, modrm{16}, reg16);
SBB.RMOW   reg16, modrm SUBFLAGS16(tmph, modrm{16}, reg16);

ARITH_C[IDX]^"RMOD" reg32, modrm 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] modrm OP2[IDX] %CF;
ADC.RMOD   reg32, modrm ADDFLAGS32(tmp1, modrm, reg32);
SBB.RMOD   reg32, modrm SUBFLAGS32(tmp1, modrm, reg32);

BT.od   modrm, reg32 
            *1* %CF := modrm@[reg32:reg32];

BTR.od   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm & ~(tmp1);

BTC.od   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm ^ tmp1;

BTS.od   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm | tmp1;

CALL.JVOW   reloc16 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc)
            *32* %pc := %pc + 3 + reloc16;

# Note: the last assignment is not correct. reloc[16 32] is the *host*
# *destination*, not the offset (the offset is not avialable to the SSL, nor
# is the "delta" required to convert from host to native.
# Corrected in the matcher file
CALL.Jvod   reloc32 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := %pc + 5 + reloc32;

CALL.APOD   seg, off 
            *32* %esp := %esp - 2
            *32* m[%esp] := %cs
            *32* %cs := seg
            *32* %esp := %esp - 4
            *16* m[%esp] := %pc
            *16* %pc := off;

CALL.EVOW   modrm 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc)
            *32* %pc := modrm{16};

CALL.EVOD   modrm 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := modrm;

CBW    
            *16* %ax := sgnex(8, 16, %al);

CWDE    
            *32* %eax := sgnex(16,32,%ax);

CLC    
            *1* %CF := 0;

CLD    
            *1* %DF := 0;

CLI    
            *1* %IF := 0;

CMC    
            *1* %CF := ~(%CF);

CMPXCHG.EV.GB   modrm, reg8 
            *8* tmpb := modrm{8}
            *8* modrm := [%al = tmpb?reg8:tmpb]
            *8* %al := [%al = tmpb?%al:tmpb]
            *1* %ZF := [%al = tmpb?1:0];

CMPXCHG.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{16}
            *16* modrm := [%ax = tmph?reg16:tmph]
            *16* %ax := [%ax = tmph?%ax:tmph]
            *1* %ZF := [%ax = tmph?1:0];

CMPXCHG.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := [%eax = tmp1?reg32:tmp1]
            *32* %eax := [%eax = tmp1?%eax:tmp1]
            *1* %ZF := [%eax = tmp1?1:0];

CWD    
            *16* %dx := [%ax < 0?-1:0];

CDQ    
            *32* %edx := [%eax < 0?-1:0];

OP4 := { "-", "+" };
DEC_INC := { "DEC", "INC" };

DEC_INC[IDX]"B" dst 
            *8* tmpb := dst
            *8* dst := dst OP4[IDX] 1;
DECB   dst SUBFLAGS8(tmpb, 1, dst);
INCB   dst ADDFLAGS8(tmpb, 1, dst);

DEC_INC[IDX]"W" dst 
            *16* tmpb := dst
            *16* dst := dst OP4[IDX] 1;
DECW   dst SUBFLAGS16(tmpb, 1, dst);
INCW   dst ADDFLAGS16(tmpb, 1, dst);

DEC_INC[IDX]"L" dst 
            *32* tmpb := dst
            *32* dst := dst OP4[IDX] 1;
DECL   dst SUBFLAGS32(tmpb, 1, dst);
INCL   dst ADDFLAGS32(tmpb, 1, dst);

DIVB   modrm 
            *16* tmph := %ax
            *8* %al := tmph / modrm{8}
            *8* %ah := tmph % modrm{8}
            undefineflags( );

DIVW   modrm 
            *32* tmp1 := (zfill(16,32,%dx) << 16) | zfill(16,32,%ax)
            *16* tmph := modrm{16}
            *16* %ax := tmp1 / tmph
            *16* %dx := tmp1 % tmph
            undefineflags( );

DIVL   modrm 
            *64* tmpl := (zfill(32,64,%edx) << 32) | zfill(32,64,%eax)
            *32* tmp2 := modrm
            *32* %eax := tmpl / tmp2
            *32* %edx := tmpl % tmp2
            undefineflags( );

ENTER   i16, i8 
            *32* tmpb := i8
            *32* %esp := %esp - 4
            *32* m[%esp] := %ebp
            *32* %FP := %esp
            *32* %ebp := %FP
            *32* %esp := %esp - i16;

IDIVB   modrm 
            *16* tmph := %ax
            *8* %al := tmph /! modrm{8}
            *8* %ah := tmph %! modrm{8}
            undefineflags( );

IDIVW   modrm 
            *32* tmp1 := (%dx << 16) | %ax
            *16* tmph := modrm{16}
            *16* %ax := tmp1 /! tmph
            *16* %dx := tmp1 %! tmph
            undefineflags( );

IDIVL   modrm 
            *64* tmpl := (%edx << 32) | %eax
            *32* tmp2 := modrm
            *32* %eax := tmpl /! tmp2
            *32* %edx := tmpl %! tmp2
            undefineflags( );

IMUL.B   modrm 
            *16* tmph := %al *! modrm{8}
            *16* %ax := tmph
            IMULTFLAGS8(tmph);

IMUL.OW   modrm 
            *32* tmp2 := %ax *! modrm
            *16* %ax := truncu(32,16,tmp2)
            *16* %dx := truncu(32,16,tmp2 >> 16)
            IMULTFLAGS16(tmp2);

IMUL.OD   modrm 
            *64* tmpl := %eax *! modrm
            *32* %eax := truncu(64,32,tmpl)
            *32* %edx := truncu(64,32,tmpl >> 32)
            IMULTFLAGS32(tmpl);

IMUL.RMOW   reg16, modrm 
            *16* reg16 := modrm{16} *! reg16
            IMULTFLAGS16(reg16);

IMUL.RMOD   reg32, modrm 
            *32* reg32 := modrm{32} *! reg32
            IMULTFLAGS32(reg32);

IMUL.IVW   reg16, modrm, i16 
            *16* reg16 := modrm{16} *! i16
            IMULTFLAGS16(reg16);

IMUL.IVD   reg32, modrm, i32 
            *32* reg32 := modrm{32} *! i32
            IMULTFLAGS32(reg32);

IMUL.Ibow   reg16, modrm, i8 
            *16* reg16 := modrm{8} *! sgnex(8,16,i8)
            IMULTFLAGS32(reg16);

IMUL.Ibod   reg32, modrm, i8 
            *32* reg32 := modrm{32} *! sgnex(8,32,i8)
            IMULTFLAGS32(reg32);

INT3
			_ ;			# Not expected to be seen in correct code, but decode anyway

COND1 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
            "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
            "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF",
            "~(%NF ^ %OF)", "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF",
            "(%NF ^ %OF) | %ZF", "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF",
            "~%ZF", "~%OF", "~%PF", "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMPS := { "JA", "JNBE", "JAE", "JNB", "JB", "JNAE", "JBE",
            "JNA", "JC", "JCXZ", "JE", "JZ", "JG", "JNLE", "JGE",
            "JNL", "JL", "JNGE", "JLE", "JNG", "JNC", "JNE", "JNZ",
            "JNO", "JNP", "JPO", "JNS", "JO", "JP", "JPE", "JS" };

JMPS[IDX]   addr 
            *32* %pc := [(COND1[IDX] = 1)?addr:%pc];

JMP   addr 
            *32* %pc := addr;

LEA.OD   reg32, mem 
            *32* reg32 := addr(mem);

LEA.OW   reg16, mem 
            *16* reg16 := addr(mem);

LEAVE    
            *32* %esp := %ebp
            *32* %ebp := m[%esp]
            *32* %esp := %esp + 4;

COND4 := { "%ecx ~= 0", "%ecx ~= 0 & %ZF", "%ecx ~= 0 & %ZF",
           "%ecx ~= 0 & ~%ZF", "%ecx ~= 0 & ~%ZF" };
LOOPS := { "LOOP", "LOOPE", "LOOPZ", "LOOPNE", "LOOPNZ" };

LOOPS[IDX]   addr 
            *32* %ecx := %ecx - 1
            *32* %pc := [COND4[IDX]?addr:%pc];

MOVB   dst, src 
            *8* dst := src;

MOVW   dst, src 
            *16* dst := src;

MOVL   dst, src 
            *32* dst := src;

MOVSX.GV.EBOW   reg16, modrm 
            *16* reg16 := sgnex(8, 16, modrm{8});

MOVSX.GV.EBOD   reg32, modrm 
            *32* reg32 := sgnex(8, 32, modrm{8});

MOVSX.GV.EW   reg32, modrm 
            *32* reg32 := sgnex(16, 32, modrm{16});

MOVZX.GV.EBOW   reg16, modrm 
            *16* reg16 := zfill(8, 16, modrm{8});

MOVZX.GV.EBOD   reg32, modrm 
            *32* reg32 := zfill(8, 32, modrm{8});

MOVZX.GV.EW   reg32, modrm 
            *32* reg32 := zfill(16, 32, modrm{16});

MUL^"AL"   modrm 
            *8* tmpb := modrm{8}
            *16* %ax := %al * tmpb
            MULTFLAGS8(%ax);

MUL.AXOW   modrm 
            *32* tmp2 := %eax * modrm{16}
            *16* %ax := tmp2
            *16* %dx := tmp2 >> 16
            MULTFLAGS16(tmp2);

MUL.AXOD   modrm 
            *32* tmp1 := modrm{32}
            *64* tmpl := zfill(32,64,%eax) * zfill(32,64,tmp1)
            *32* %eax := tmpl
            *32* %edx := tmpl >> 32
            MULTFLAGS32(tmpl);

NEGB   modrm 
            *8* tmpb := modrm{8}
            *8* modrm := 0 - modrm{8}
            SUBFLAGS8(0, tmpb, modrm{8});

NEG.OW   modrm 
            *16* tmph := modrm{16}
            *16* modrm := 0 - modrm{16}
            SUBFLAGS16(0, tmph, modrm);

NEG.OD   modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := 0 - modrm{32}
            SUBFLAGS32(0, tmp1, modrm);

NOP    
            _ ;

NOTB   modrm 
            *8* modrm := ~modrm{8};

NOT.OW   modrm 
            *16* modrm := ~modrm{16};

NOT.OD   modrm 
            *32* modrm := ~modrm{32};

POP.EVOW   modrm 
            *16* modrm := m[%esp]
            *32* %esp := %esp + 2;

POP.EVOD   modrm 
            *32* modrm := m[%esp]
            *32* %esp := %esp + 4;

POP.OW   reg16 
            *16* reg16 := m[%esp]{16}
            *32* %esp := %esp + 2;

POP.OD   reg32 
            *32* reg32 := m[%esp]{32}
            *32* %esp := %esp + 4;

PUSH.EVOW   modrm 
            *32* %esp := %esp - 2
            *16* m[%esp] := modrm{16};

PUSH.EVOD   modrm 
            *32* %esp := %esp - 4
            *32* m[%esp] := modrm{32};

PUSH.IXOB   i8 
            *32* %esp := %esp - 4
            *32* m[%esp] := sgnex(8, 32, i8);

# Note: 66 6A nn: 8 bit immediate operand (nn), but 16 bit push!
PUSH.IXOW   i8
            *16* %esp := %esp - 2
            *16* m[%esp] := sgnex(8, 16, i8);

PUSH.IVOW   i16 
            *32* %esp := %esp - 2
            *16* m[%esp] := i16;

PUSH.IVOD   i32 
            *32* %esp := %esp - 4
            *32* m[%esp] := i32;

PUSH.OW   reg16 
            *32* %esp := %esp - 2
            *16* m[%esp] := reg16;

PUSH.OD   reg32 
            *32* %esp := %esp - 4
            *32* m[%esp] := reg32;

# Just fix up the stack for selector pushes.
PUSH.CS
            *32* %esp := %esp - 4;
	    
PUSH.DS
            *32* %esp := %esp - 4;

PUSH.ES
            *32* %esp := %esp - 4;

OP4 := { "rlc", "rrc", "rl", "rr" };
ROT := { "RCL", "RCR", "ROL", "ROR" };

ROLS := { "RCL","ROL" };
RORS := { "RCR","ROR" };
ROT[IDX].B.EV.1 modrm 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb OP4[IDX] 1
            *8* modrm := tmpb2;
ROLS[IDX].B.EV.1 modrm   ROLFLAGS8(tmpb2, tmpb1, 1);
RORS[IDX].B.EV.1 modrm   RORFLAGS8(tmpb2, tmpb1, 1);

ROT[IDX].B.EV.1OW modrm 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] 1
            *16* modrm := tmph2;
ROLS[IDX].B.EV.1OW modrm   ROLFLAGS16(tmph2, tmph1, 1);
RORS[IDX].B.EV.1OW modrm   RORFLAGS16(tmph2, tmph1, 1);

ROT[IDX].B.EV.1OD modrm 
            *32* tmp1 := modrm{32}
            *32* tmp2 := tmp1 OP4[IDX] 1
            *32* modrm := tmp2;
ROLS[IDX].B.EV.1OD modrm   ROLFLAGS32(tmp2, tmp1, 1);
RORS[IDX].B.EV.1OD modrm   RORFLAGS32(tmp2, tmp1, 1);

ROT[IDX].B.EV.CL modrm 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb1 OP4[IDX] %ecx
            *8* modrm := tmpb2;
ROLS[IDX].B.EV.CL   modrm  ROLFLAGS8(tmpb2, tmpb1, %ecx);
RORS[IDX].B.EV.CL   modrm  RORFLAGS8(tmpb2, tmpb1, %ecx);

ROT[IDX].B.EV.CLOW modrm 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] %ecx
            *16* modrm := tmph2;
ROLS[IDX].B.EV.CLOW   modrm  ROLFLAGS16(tmph2, tmph1, %ecx);
RORS[IDX].B.EV.CLOW   modrm  RORFLAGS16(tmph2, tmph1, %ecx);

ROT[IDX].B.EV.CLOD modrm 
            *32* tmp1 := modrm{32}
            *32* tmp2 := tmp1 OP4[IDX] %ecx
            *32* modrm := tmp2;
ROLS[IDX].B.EV.CLOD   modrm  ROLFLAGS32(tmp2, tmp1, %ecx);
RORS[IDX].B.EV.CLOD   modrm  RORFLAGS32(tmp2, tmp1, %ecx);

ROT[IDX].B.EB.IB modrm, i8 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb1 OP4[IDX] i8
            *8* modrm := tmpb2;
ROLS[IDX].B.EB.IB   modrm, i8  ROLFLAGS8(tmpb2, tmpb1, i8);
RORS[IDX].B.EB.IB   modrm, i8  RORFLAGS8(tmpb2, tmpb1, i8);

ROT[IDX].B.EV.IBOW modrm, i8 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] sgnex(8, 16, i8)
            *16* modrm := tmph2;
ROLS[IDX].B.EV.IBOW   modrm, i8  
            ROLFLAGS16(tmph2, tmph1, i8);
RORS[IDX].B.EV.IBOW   modrm, i8  
            RORFLAGS16(tmph2, tmph1, i8);

ROT[IDX].B.EV.IBOD modrm, i8 
            *32* tmp1 := modrm{8}
            *32* tmp2 := tmp1 OP4[IDX] i8
            *32* modrm := tmp2;
ROLS[IDX].B.EV.IBOD   modrm, i8  ROLFLAGS32(tmp2, tmp1, i8);
RORS[IDX].B.EV.IBOD   modrm, i8  RORFLAGS32(tmp2, tmp1, i8);

RET    
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4;

RET.IW   i16 
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4 + i16;

SAHF    
            *1* %NF := %ah@[7:7]
            *1* %ZF := %ah@[6:6]
            *1* %PF := %ah@[2:2]
            *1* %CF := %ah@[0:0];

SEG.CS      _;          # Sometimes used for extended NOP
SEG.DS      _;
SEG.ES      _;
SEG.SS      _;

SETB.B   modrm 
            *8* modrm := [%CF?1:0];

SETB.NB   modrm 
            *8* modrm := [~%CF?1:0];

SETB.BE   modrm 
            *8* modrm := [%CF | %ZF?1:0];

SETB.NBE   modrm 
            *8* modrm := [~%CF & ~%ZF?1:0];

SETB.L   modrm 
            *8* modrm := [%NF! = %OF?1:0];

SETB.NL   modrm 
            *8* modrm := [%NF = %OF?1:0];

SETB.O   modrm 
            *8* modrm := [%OF?1:0];

SETB.NO   modrm 
            *8* modrm := [~%OF?1:0];

SETB.P   modrm 
            *8* modrm := [%PF?1:0];

SETB.NP   modrm 
            *8* modrm := [~%PF = 0?1:0];

SETB.S   modrm 
            *8* modrm := [%NF?1:0];

SETB.NS   modrm 
            *8* modrm := [~%NF?1:0];

SETB.Z   modrm 
            *8*  modrm := [%ZF?1:0];

SETB.NZ   modrm 
            *8* modrm := [~%ZF?1:0];

SETB.LE   modrm 
            *8* modrm := [%ZF | (%NF ~= %OF) ?1:0];

SETB.NLE   modrm 
            *8* modrm := [~%ZF & (%NF = %OF) ?1:0];

OP5 := { "<<", ">>A", ">>" };
SHT := { "SHLSAL", "SAR", "SHR" };

SHT[IDX]"B" dst, cnt 
            *8* tmpb := dst
            *8* dst := dst OP5[IDX] cnt;
SHLSALB   dst, cnt   SALFLAGS8(dst, tmpb, cnt);
SARB   dst, cnt   SARFLAGS(dst, tmpb, cnt);
SHRB   dst, cnt   SHRFLAGS8(dst, tmpb, cnt);

SHT[IDX]"W" dst, cnt 
            *16* tmph := dst
            *16* dst := dst OP5[IDX] cnt;
SHLSALW   dst, cnt   SALFLAGS16(dst, tmph, cnt);
SARW   dst, cnt   SARFLAGS(dst, tmph, cnt);
SHRW   dst, cnt   SHRFLAGS16(dst, tmph, cnt);

SHT[IDX]"L" dst, cnt 
            *32* tmp1 := dst
            *32* dst := dst OP5[IDX] cnt;
SHLSALL   dst, cnt   SALFLAGS32(dst, tmp1, cnt);
SARL   dst, cnt   SARFLAGS(dst, tmp1, cnt);
SHRL   dst, cnt   SHRFLAGS32(dst, tmp1, cnt);

OP6 := { "<<", ">>" };
SHTD := { "SHLD", "SHRD" };

SHTD[IDX].CLOW modrm, reg16 
            *32* tmp1 := [%cl > 31?%cl:31]
            *32* tmp2 := reg16 << 16
            *32* tmp3 := tmp2 + modrm{16}
            *32* tmp5 := tmp3 OP6[IDX] tmp1
            *16* modrm := tmp5;
SHLD.CLOW   modrm, reg16  SHLDFLAGS32(tmp5, tmp3, tmp1);
SHRD.CLOW   modrm, reg16  SHRDFLAGS32(tmp5, tmp3, tmp1);

SHTD[IDX].CLOD modrm, reg32 
            *32* tmp1 := [%cl > 31?%cl:31]
            *64* tmp2 := reg32 << 32
            *64* tmp3 := tmp2 + modrm
            *64* tmp5 := tmp3 OP6[IDX] tmp1
            *32* modrm := tmp5;
SHLD.CLOD   modrm, reg32  SHLDFLAGS64(tmp5, tmp3, tmp1);
SHRD.CLOD   modrm, reg32  SHRDFLAGS64(tmp5, tmp3, tmp1);

SHTD[IDX].IBOW modrm, reg16, cnt 
            *32* tmp1 := [cnt > 31?cnt:31]
            *32* tmp2 := reg16 << 16
            *32* tmp3 := tmp2 + modrm{16}
            *32* tmp5 := tmp3 OP6[IDX] tmp1
            *16* modrm := tmp5;
SHLD.IBOW   modrm, reg16, cnt   SHLDFLAGS32(tmp5, tmp3, tmp1);
SHRD.IBOW   modrm, reg16, cnt   SHRDFLAGS32(tmp5, tmp3, tmp1);

SHTD[IDX].IBOD modrm, reg32, cnt 
            *32* tmp1 := [cnt > 31?cnt:31]
            *64* tmp2 := reg32 << 32
            *64* tmp3 := tmp2 + modrm{32}
            *64* tmp5 := tmp3 OP6[IDX] tmp1
            *32* modrm := tmp5;
SHLD.IBOD   modrm, reg32, cnt  SHLDFLAGS64(tmp5, tmp3, tmp1);
SHRD.IBOD   modrm, reg32, cnt  SHRDFLAGS64(tmp5, tmp3, tmp1);

STC    *1* %CF := 1;

STD    *1* %DF := 1;

STI    *1* %IF := 1;

# The string instructions
REPS := {"REP", "REPNE"};                   # Repeat prefixes
OREPS := { REPS, ""};                       # Optional repeat prefixes
ALLSZ := {"B", "VOW", "VOD"};               # All size suffixes

# String instructions, not repeated
STRS := { "CMPS", "LODS", "MOVS", "SCAS", "STOS" };

# String instructions, repeated
STRS_R := REPS STRS;

# String instructions, optionally repeated
STRS_OR := OREPS STRS;

STRFL :=       { "CMPS", "SCAS"};                   # Update flags
STRNF :=       { "LODS", "MOVS", "STOS"};           # No update flags
STRSI := OREPS { "CMPS", "LODS", "MOVS" };          # Update esi
STRDI := OREPS { "CMPS", "MOVS", "SCAS", "STOS" };  # Update edi
STRFL_OR := OREPS STRFL;                            # Optionally repeated; flags

CMPS_OR := OREPS CMPS;      # Compare with optional repeat
LODS_OR := OREPS LODS;      # Load with optional repeat
MOVS_OR := OREPS MOVS;      # Move with optional repeat
SCAS_OR := OREPS SCAS;      # Scan with optional repeat
STOS_OR := OREPS STOS;      # Store with optional repeat

# All repeated string instructions
STRS_R[X]ALLSZ[Y]
            *1* %SKIP := (%ecx = 0);

CMPS_OR[X].B
            *8* tmpb := m[%esi]{8} - m[%edi]{8};
LODS_OR[X].B   
            *8* %al := m[%esi]{8};
MOVS_OR[X].B   
            *8* m[%edi] := m[%esi]{8};
SCAS_OR[X].B   
            *8* tmpb := %al - m[%edi]{8};
STOS_OR[X].B   
            *8* m[%edi] := %al;
STRFL_OR[X].B   
            SUBFLAGS8(m[%esi]{8}, m[%edi]{8}, tmpb);
STRSI[IDX].B   
            *32* %esi := %esi + [%DF = 0?1:-1];
STRDI[IDX].B   
            *32* %edi := %edi + [%DF = 0?1:-1];

CMPS_OR[X].W   
            *16* tmph := m[%esi]{16} - m[%edi]{16};
LODS_OR[X].W   
            *16* %eax := m[%esi]{16};
MOVS_OR[X].W   
            *16* m[%edi] := m[%esi]{16};
SCAS_OR[X].W   
            *16* tmph := %eax - m[%edi];
STOS_OR[X].W   
            *16* m[%edi] := %eax;
STRFL_OR[X].W   
            SUBFLAGS16(m[%esi]{16}, m[%edi]{16}, tmph);
STRSI[IDX].W   
            *16* %esi := %esi + [%DF = 0?2:-2];
STRDI[IDX].W   
            *16* %edi := %edi + [%DF = 0?2:-2];

CMPS_OR[X].L   
            *32* tmp1 := m[%esi]{32} - m[%edi]{32};
LODS_OR[X].L   
            *32* %eax := m[%esi]{32};
MOVS_OR[X].L   
            *32* m[%edi] := m[%esi]{32};
SCAS_OR[X].L   
            *32* tmp1 := %eax - m[%edi];
STOS_OR[X].L   
            *32* m[%edi] := %eax;
STRFL_OR[X].L   
            SUBFLAGS32(m[%esi]{32}, m[%edi]{32}, tmp1);
STRSI[IDX].L   
            *32* %esi := %esi + [%DF = 0?4:-4];
STRDI[IDX].L   
            *32* %edi := %edi + [%DF = 0?4:-4];

# All repeated instructions decrement %ecx
STRS_R[X]ALLSZ[Y]
            *32* %ecx := %ecx - 1;

# Do the repeat logic
REPIFZ := REP STRFL;
REPIFZ[X]ALLSZ[Y]
            *1* %RPT := %ZF;

REPIFNZ := REPNE STRFL;
REPIFNZ[X]ALLSZ[Y]
            *1* %RPT := ~%ZF;

REPALL := REPS STRNF;
REPALL[X]ALLSZ[Y]
            *1* %RPT := 1;

# End string instructions


TESTB   modrm, reg8 
            *8* tmpb := modrm & reg8
            LOGICALFLAGS8(tmpb);

TESTW   modrm, reg16 
            *16* tmph := modrm & reg16
            LOGICALFLAGS16(tmph);

TESTL   modrm, reg32 
            *32* tmp1 := modrm & reg32
            LOGICALFLAGS32(tmp1);

WAIT    _ ;

XADDB   modrm, reg8 
            *8* tmp1 := modrm
            *8* tmp2 := reg8
            *8* modrm := tmp1 + reg8
            *8* reg8 := tmp1
            ADDFLAGS8(tmp1, tmp2, modrm);

XADDW   modrm, reg16 
            *16* tmp1 := modrm
            *16* tmp2 := reg16
            *16* modrm := tmp1 + reg16
            *16* reg16 := tmp1
            ADDFLAGS16(tmp1, tmp2, modrm);

XADDL   modrm, reg32 
            *32* tmp1 := modrm
            *32* tmp2 := reg32
            *32* modrm := tmp1 + reg32
            *32* reg32 := tmp1
            ADDFLAGS32(tmp1, tmp2, modrm);

XCHGB   modrm, reg8 
            *8* tmpb := modrm
            *8* modrm := reg8
            *8* reg8 := tmpb;

XCHGW   modrm, reg16 
            *16* tmph := modrm
            *16* modrm := reg16
            *16* reg16 := tmph;

XCHGL   modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := reg32
            *32* reg32 := tmp1;

# Start of Floating point operators

F2XM1
            # Compute (2^x)-1
            # Note: pwr is the binary "raise to power of" operator
            *f80* %st := (2.0 pow %st) -f 1.0;

FABS    
            *f80* %st := fabs(%st);

OP3 := { "+f", "-f" };
FARIT := { "FADD", "FSUB" };

FARIT[IDX].r32 modrm 
            *f80* %st := %st OP3[IDX] fsize(32,80,modrm);

FARIT[IDX].r64 modrm 
            *f80* %st := %st OP3[IDX] fsize(64,80,modrm);

FARIT[IDX].ST.STi i
            *f80* %st := %st OP3[IDX] i;

FARIT[IDX].STi.ST i 
            *f80* i := i OP3[IDX] %st;

FARITP := { "FADDP", "FSUBP" };

FARITP[IDX].r32 modrm 
            *f80* %st := %st OP3[IDX] fsize(32,80,modrm)
            FPOP;

FARITP[IDX].r64 modrm 
            *f80* %st := %st OP3[IDX] fsize(64,80,modrm)
            FPOP;

FARITP[IDX].ST.STi i 
            *f80* %st := %st OP3[IDX] i
            FPOP;

FARITP[IDX].STi.ST i 
            *f80* i := i OP3[IDX] %st
            FPOP;

FIADD.i16   modrm 
            *f80* %st := %st +f itof(16,80,modrm);

FIADD.i32   modrm 
            *f80* %st := %st +f itof(32,80,modrm);

FCHS    
            *f80* %st := ~f %st;

FCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FNCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FCOM.r32    modrm 
            *f80* tmpD := %st -f fsize(32,80,modrm)
            SETFFLAGS(%st, fsize(32,80,modrm));

FCOM.r64    modrm 
            *f80* tmpD := %st -f fsize(64,80,modrm)
            SETFFLAGS(%st, fsize(64,80,modrm));

FCOM.ST.STi i 
            *f80* tmpD := %st -f i
            SETFFLAGS(%st, i);

FCOMP.r32   modrm 
            # Note that the FPOP will actually change the register numbers!
            *f80* tmpD1 := %st
            *f80* tmpD2 := fsize(32, 80, modrm)
            *f80* tmpD := %st -f fsize(32,80,modrm)
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FCOMP.r64   modrm 
            *f80* tmpD1 := %st
            *f80* tmpD2 := fsize(64, 80, modrm)
            *f80* tmpD := %st -f fsize(64,80,modrm)
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FCOMP.ST.STi   i 
            *f80* tmpD1 := %st
            *f80* tmpD2 := i
            *f80* tmpD := %st -f i
            FPOP
            SETFFLAGS(tmpD1, tmpD2);
FCOMPP    
            *f80* tmpD1 := %st
            *f80* tmpD2 := %st1
            *f80* tmpD := %st -f %st1
            FPOP
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FCOS    
            *f80* %st := cos(%st);

FPUSH_
            FPUSH;

FDIV.r32   modrm 
            *f80* %st := %st /f fsize(32,80,modrm);

FDIV.r64   modrm 
            *f80* %st := %st /f fsize(64,80,modrm);

FDIV.ST.STi   i 
            *f80* %st := %st /f i;

# At this point, it should be noted that Intel have an unusual way of
# defining what is and isn't an "R" (reverse operands) instruction.
# Beware! Many disassemblers and assemblers get it wrong.
# Of course, gcc uses "AT&T" syntax, so that makes it more confusing again.
# Note that the decoder now gets the names right, as per the Intel manual.
# Note: some older Intel manuals have errors in the FSUB and FSUBR
# instructions.

FDIV.STi.ST   i 
            *f80* i := i /f %st;

FDIVP.STi.ST   i 
            *f80* i := i /f %st
            FPOP;

FIDIV.i32   modrm 
            *f80* %st := %st /f itof(32,80,modrm);

FIDIV.i16   modrm 
            *f80* %st := %st /f itof(16,80,modrm);

FDIVR.r32   modrm 
            *f80* %st := fsize(32,80,modrm) /f %st;

FDIVR.r64   modrm 
            *f80* %st := fsize(64,80,modrm) /f %st;

FDIVR.ST.STi   i 
            *f80* %st := i /f %st;

FDIVR.STi.ST   i 
            *f80* i := %st /f i;

FDIVRP.STi.ST   i 
            *f80* i := %st /f i
            FPOP;

FIDIVR.i32   modrm 
            *f80* %st := itof(32,80,modrm) /f %st;

FIDIVR.i16   modrm 
            *f80* %st := itof(16,80,modrm) /f %st;

FICOM.i16   modrm 
            *f80* tmpD := %st -f itof(16,80,modrm)
            SETFFLAGS(%st, itof(16,80,modrm));

FICOM.i32   modrm 
            *f80* tmpD := %st -f itof(32,80,modrm)
            SETFFLAGS(%st, itof(32,80,modrm));

FICOMP.i16   modrm 
            *f80* tmpD := %st -f itof(16,80,modrm)
            FPOP
            SETFFLAGS(%st, itof(16,80,modrm));

FICOMP.i32   modrm 
            *f80* tmpD := %st -f itof(32,80,modrm)
            FPOP
            SETFFLAGS(%st, itof(32,80,modrm));

FILD.lsI16   modrm 
            FPUSH
            *f80* %st := itof(16,80,modrm);

FILD.lsI32   modrm 
            FPUSH
            *f80* %st := itof(32,80,modrm);

FILD.lsI64   modrm 
            FPUSH
            *f80* %st := itof(64,80,modrm);

FINCSTP    
            FPUSH;

FINIT
            _ ;               # No operation; may find in startup code

FIST.lsI16   modrm 
            *16* modrm := ftoi(80,16,%st);

FIST.lsI32   modrm 
            *32* modrm := ftoi(80,32,%st);

FISTP.lsI16   modrm 
            *16* modrm := ftoi(80,16,%st)
            FPOP;

FISTP.lsI32   modrm 
            *32* modrm := ftoi(80,32,%st)
            FPOP;

FISTP64     modrm 
            *64* modrm := ftoi(80,64,%st)
            FPOP;

FLD.lsR32   modrm 
            FPUSH
            *f80* %st := fsize(32,80,modrm);

FLD.lsR64   modrm 
            FPUSH
            *f80* %st := fsize(64,80,modrm);

FLD80       modrm 
            FPUSH
            *f80* %st := modrm;

# This is a bit tricky. The FPUSH logically comes between the read of STi and
# the write to ST0. In particular, FLD ST0 is supposed to duplicate the TOS.
# This problem only happens with this load instruction, so there is a work
# around in the decoder that gives us a value of i that is one more than in
# the instruction

FLD.STi     i 
            FPUSH
            *f80* %st := i;

FLD1    
            FPUSH
            *f80* %st := 1.0;

FLDL2T    
            FPUSH
            *f80* %st := log2(10.0);

FLDL2E    
            FPUSH
            *f80* %st := log2(2.7182818);

FLDPI    
            FPUSH
            *f80* %st := 3.1415926;

FLDLG2    
            FPUSH
            *f80* %st := log10(2.0);

FLDLN2    
            FPUSH
            *f80* %st := loge(2.0);

FLDZ    
            FPUSH
            *f80* %st := 0.0;

FLDCW   modrm 
            *16* %fcw := modrm;

FMUL.r32   modrm 
            *f80* %st := %st *f fsize(32,80,modrm);

FMUL.r64   modrm 
            *f80* %st := %st *f fsize(64,80,modrm);

FMUL.ST.STi   i 
            *f80* %st := %st *f i;

FMUL.STi.ST   i 
            *f80* i := %st *f i;

FMULP.STi.ST   i 
            *f80* i := %st *f i
            FPOP;

FIMUL.i16   modrm 
            *f80* %st := %st *f itof(16,80,modrm);

FIMUL.i32   modrm 
            *f80* %st := %st *f itof(32,80,modrm);

FNOP    _ ;

FPATAN    
            *f80* %st1 := arctan(%st1 /f %st)
            FPOP;

# FPREM is for backwards compatibility with 80{2}87 FPUs
FPREM
            *f80* tmpD := ftrunc(%st /f %st1)   # Should chop towards 0
            *f80* %st := %st -f (%st1 *f tmpD)
# If st1 was/is negative, we need to change the sign of st?
            *f80* %st := [%st1 < 0 ? ~f %st : %st];
            #*1* %C2 := 0
            #*1* %FZF := bit 2 of tmpD as integer  # %C0 is %FZF
            #*1* %FLF := bit 1 of tmpD as integer  # %C3 is %FLF
            #*1* %C1  := bit 0 of tmpD as integer

# Floating point remainder.
FPREM1
            *f80* tmpD := ftrunc(%st /f %st1)   # Should round to nearest
            *f80* %st := %st -f (%st1 *f tmpD);
            #*1* %C2 := 0
            #*1* %FZF := bit 2 of tmpD as integer  # %C0 is %FZF
            #*1* %FLF := bit 1 of tmpD as integer  # %C3 is %FLF
            #*1* %C1  := bit 0 of tmpD as integer

FPTAN    
            *f80* %st := tan(%st)
            FPUSH
            *f80* %st := 1.0;

FRNDINT    
            *f80* %st := fround(80,80,%st);

FSCALE      # Raise 2 to an integer power and multiply
            # Note that st1 is "chopped" before use
            *f80* %st := %st * (2.0 pow ftrunc(%st1));

FSIN    
            *f80* %st := sin(%st);

FSINCOS    
            *f80* tmp := %st
            *f80* %st := sin(tmp)
            FPUSH
            *f80* %st := cos(tmp);

FSQRT    
            *f80* %st := sqrt(%st);

FST.lsR32   modrm 
            *32* modrm := fsize(80,32,%st);

FST.lsR64   modrm 
            *64* modrm := fsize(80,64,%st);

FST.ST.STi   i 
            *f80* i := %st;

FSTP.lsR32   modrm 
            *32* modrm := fsize(80,32,%st)
            FPOP;

FSTP.lsR64   modrm 
            *64* modrm := fsize(80,64,%st)
            FPOP;

FSTP80   modrm 
            *f80* modrm := %st
            FPOP;

FSTP.ST.STi   i 
            *f80* i := %st
            FPOP;

FSTCW   modrm 
            *16* modrm := %fcw;

FNSTCW   modrm 
            *16* modrm := %fcw;

FSTSW   modrm 
            *16* modrm := %fflags;

FSTSW.AX    
            # *16* %ax := %fflags;
            *8* %ah := %fflags
            *8* %al := 0;     # Just so we know it's changed  

FNSTSW   modrm 
            *16* modrm := %fflags;

FNSTSW.AX    
            # *16* %ax := %fflags;
            *8* %ah := %fflags
            *8* %al := 0;     # Just so we know it's changed  

FSUBR.r32   modrm 
            *f80* %st := fsize(32,80,modrm) -f %st;

FSUBR.r64   modrm 
            *f80* %st := fsize(64,80,modrm) -f %st;

FSUBR.ST.STi   i 
            *f80* %st := i -f %st;

# We used to think this one had to be swapped
FSUBR.STi.ST   i 
            *f80* i := %st -f i;

# We used to think this one had to be swapped
FSUBRP.STi.ST   i 
            *f80* i := %st -f i
            FPOP;

FISUB.i32   modrm 
            *f80* %st := %st -f itof(32,80,modrm);

FISUB.i16   modrm 
            *f80* %st := %st - itof(16,80,modrm);

FISUBR.i32   modrm 
            *f80* %st := itof(32,80,modrm) -f %st;

FISUBR.i16   modrm 
            *f80* %st := itof(16,80,modrm) -f %st;

FTST    
            SETFFLAGS(%st, 0.0);

FUCOM       i 
            *f80* tmpD := %st -f i
            SETFFLAGS(%st, i);

FUCOMI.ST.STi	i 
			*f80* tmpD := %st -f i
			SUBFLAGSFL(%st, i);

FUCOMP      i 
            *f80* tmpD1 := %st
            *f80* tmpD2 := i
            *f80* tmpD := %st -f i
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FUCOMIP.ST.STi	i 
            *f80* tmpD1 := %st
            *f80* tmpD2 := i
            *f80* tmpD := %st -f i
            FPOP
            SUBFLAGSFL(tmpD1, tmpD2);

FUCOMPP    
            *f80* tmpD1 := %st
            *f80* tmpD2 := %st1
            *f80* tmpD := %st -f %st1
            FPOP
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FWAIT    _ ;

FXCH        i 
            *f80* tmpD := %st
            *f80* %st := i
            *f80* i := tmpD;

FYL2X    
            *f80* %st1 := %st1 *f log2(%st)
            FPOP;

FYL2XP1    
            *f80* %st1 := %st1 *f log2(%st +f 1.0)
            FPOP;

#####################################################################
# These are the semantics for certain prologues and epilogues that we
# need to see for CSR analysis. We need the semantics for a logue to
# be specified when it uses and/or defines locations that relevant for
# CSR analysis involving the logue. For example, the caller prologue
# "clear_stack" on x86 directly manipulates the stack pointer which is
# something the abstract frame pointer needs to see.
#####################################################################
CLEAR_STACK   n 
            *32* %esp := %esp + n;
